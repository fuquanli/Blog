<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker配置加速器</title>
    <url>/2020/03/15/Docker%E9%85%8D%E7%BD%AE%E5%8A%A0%E9%80%9F%E5%99%A8/</url>
    <content><![CDATA[<p>有时使用Docker拉取镜像慢如蜗牛，这个时候就需要配置下加速器，Docker 官方和国内很多云服务商都提供了国内加速器服务。</p>
<p>如Docker官方提供中国镜像库：<strong><a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></strong></p>
<p>阿里的加速器：<strong><a href="https://5ch7vat9.mirror.aliyuncs.com/">https://5ch7vat9.mirror.aliyuncs.com</a></strong></p>
<span id="more"></span>

<p>这里我使用的是阿里的加速器，使用了一阶段，感觉还不错，大大的提高了拉取镜像的速度。</p>
<p>如何配置？</p>
<p>首先进入docker目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/docker</span><br></pre></td></tr></table></figure>

<p>创建并编辑文件daemon.json</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim daemon.json</span><br></pre></td></tr></table></figure>

<p>编辑内容为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;     </span><br><span class="line">    <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://5ch7vat9.mirror.aliyuncs.com&quot;</span>]  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新启动docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload </span><br><span class="line">sudo systemctl restart docker </span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>GIT常用命令</title>
    <url>/2023/07/12/GIT%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><strong>GIT中常用的一些命令</strong></p>
<span id="more"></span>


<blockquote>
<p>作者：阮一峰 <a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">常用 Git 命令清单 - 阮一峰的网络日志 (ruanyifeng.com)</a></p>
</blockquote>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png" alt="命令"></p>
<h1 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h1><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line"><span class="variable">$</span> git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line"><span class="variable">$</span> git init [<span class="type">project</span>-<span class="type">name</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载一个项目和它的整个代码历史</span></span><br><span class="line"><span class="variable">$</span> git clone [<span class="type">url</span>]</span><br></pre></td></tr></table></figure>

<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前的Git配置</span></span><br><span class="line"><span class="variable">$</span> git config <span class="literal">--list</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Git配置文件</span></span><br><span class="line"><span class="variable">$</span> git config <span class="literal">-e</span> [--<span class="type">global</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置提交代码时的用户信息</span></span><br><span class="line"><span class="variable">$</span> git config [--<span class="type">global</span>] user.name <span class="string">&quot;[name]&quot;</span></span><br><span class="line"><span class="variable">$</span> git config [--<span class="type">global</span>] user.email <span class="string">&quot;[email address]&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="增加-x2F-删除文件"><a href="#增加-x2F-删除文件" class="headerlink" title="增加&#x2F;删除文件"></a>增加&#x2F;删除文件</h1><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line"><span class="variable">$</span> git add [<span class="type">file1</span>] [<span class="type">file2</span>] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line"><span class="variable">$</span> git add [<span class="type">dir</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line"><span class="variable">$</span> git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line"><span class="variable">$</span> git add <span class="literal">-p</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line"><span class="variable">$</span> git <span class="built_in">rm</span> [<span class="type">file1</span>] [<span class="type">file2</span>] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line"><span class="variable">$</span> git <span class="built_in">rm</span> <span class="literal">--cached</span> [<span class="type">file</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line"><span class="variable">$</span> git <span class="built_in">mv</span> [<span class="type">file</span>-<span class="type">original</span>] [<span class="type">file</span>-<span class="type">renamed</span>]</span><br></pre></td></tr></table></figure>

<h1 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h1><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提交暂存区到仓库区</span></span><br><span class="line"><span class="variable">$</span> git commit <span class="literal">-m</span> [<span class="type">message</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交暂存区的指定文件到仓库区</span></span><br><span class="line"><span class="variable">$</span> git commit [<span class="type">file1</span>] [<span class="type">file2</span>] ... <span class="literal">-m</span> [<span class="type">message</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line"><span class="variable">$</span> git commit <span class="literal">-a</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交时显示所有diff信息</span></span><br><span class="line"><span class="variable">$</span> git commit <span class="literal">-v</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line"><span class="variable">$</span> git commit <span class="literal">--amend</span> <span class="literal">-m</span> [<span class="type">message</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line"><span class="variable">$</span> git commit <span class="literal">--amend</span> [<span class="type">file1</span>] [<span class="type">file2</span>] ...</span><br></pre></td></tr></table></figure>

<h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line"><span class="variable">$</span> git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line"><span class="variable">$</span> git branch <span class="literal">-r</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有本地分支和远程分支</span></span><br><span class="line"><span class="variable">$</span> git branch <span class="literal">-a</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line"><span class="variable">$</span> git branch [<span class="type">branch</span>-<span class="type">name</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line"><span class="variable">$</span> git checkout <span class="literal">-b</span> [<span class="type">branch</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向指定commit</span></span><br><span class="line"><span class="variable">$</span> git branch [<span class="type">branch</span>] [<span class="type">commit</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line"><span class="variable">$</span> git branch <span class="literal">--track</span> [<span class="type">branch</span>] [<span class="type">remote</span>-<span class="type">branch</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定分支，并更新工作区</span></span><br><span class="line"><span class="variable">$</span> git checkout [<span class="type">branch</span>-<span class="type">name</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到上一个分支</span></span><br><span class="line"><span class="variable">$</span> git checkout -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line"><span class="variable">$</span> git branch <span class="literal">--set-upstream</span> [<span class="type">branch</span>] [<span class="type">remote</span>-<span class="type">branch</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line"><span class="variable">$</span> git merge [<span class="type">branch</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line"><span class="variable">$</span> git cherry<span class="literal">-pick</span> [<span class="type">commit</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line"><span class="variable">$</span> git branch <span class="literal">-d</span> [<span class="type">branch</span>-<span class="type">name</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line"><span class="variable">$</span> git push origin <span class="literal">--delete</span> [<span class="type">branch</span>-<span class="type">name</span>]</span><br><span class="line"><span class="variable">$</span> git branch <span class="literal">-dr</span> [<span class="type">remote</span>/<span class="type">branch</span>]</span><br></pre></td></tr></table></figure>

<h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有tag</span></span><br><span class="line"><span class="variable">$</span> git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在当前commit</span></span><br><span class="line"><span class="variable">$</span> git tag [<span class="type">tag</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在指定commit</span></span><br><span class="line"><span class="variable">$</span> git tag [<span class="type">tag</span>] [<span class="type">commit</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地tag</span></span><br><span class="line"><span class="variable">$</span> git tag <span class="literal">-d</span> [<span class="type">tag</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程tag</span></span><br><span class="line"><span class="variable">$</span> git push origin :refs/tags/[<span class="type">tagName</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看tag信息</span></span><br><span class="line"><span class="variable">$</span> git show [<span class="type">tag</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交指定tag</span></span><br><span class="line"><span class="variable">$</span> git push [<span class="type">remote</span>] [<span class="type">tag</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交所有tag</span></span><br><span class="line"><span class="variable">$</span> git push [<span class="type">remote</span>] <span class="literal">--tags</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向某个tag</span></span><br><span class="line"><span class="variable">$</span> git checkout <span class="literal">-b</span> [<span class="type">branch</span>] [<span class="type">tag</span>]</span><br></pre></td></tr></table></figure>

<h1 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h1><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示有变更的文件</span></span><br><span class="line"><span class="variable">$</span> git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的版本历史</span></span><br><span class="line"><span class="variable">$</span> git log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line"><span class="variable">$</span> git log <span class="literal">--stat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索提交历史，根据关键词</span></span><br><span class="line"><span class="variable">$</span> git log <span class="literal">-S</span> [<span class="type">keyword</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line"><span class="variable">$</span> git log [<span class="type">tag</span>] HEAD <span class="literal">--pretty</span>=format:%s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span></span><br><span class="line"><span class="variable">$</span> git log [<span class="type">tag</span>] HEAD <span class="literal">--grep</span> feature</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line"><span class="variable">$</span> git log <span class="literal">--follow</span> [<span class="type">file</span>]</span><br><span class="line"><span class="variable">$</span> git whatchanged [<span class="type">file</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件相关的每一次diff</span></span><br><span class="line"><span class="variable">$</span> git log <span class="literal">-p</span> [<span class="type">file</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示过去5次提交</span></span><br><span class="line"><span class="variable">$</span> git log <span class="literal">-5</span> <span class="literal">--pretty</span> <span class="literal">--oneline</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line"><span class="variable">$</span> git shortlog <span class="literal">-sn</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line"><span class="variable">$</span> git blame [<span class="type">file</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和工作区的差异</span></span><br><span class="line"><span class="variable">$</span> git <span class="built_in">diff</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和上一个commit的差异</span></span><br><span class="line"><span class="variable">$</span> git <span class="built_in">diff</span> <span class="literal">--cached</span> [<span class="type">file</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line"><span class="variable">$</span> git <span class="built_in">diff</span> HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示两次提交之间的差异</span></span><br><span class="line"><span class="variable">$</span> git <span class="built_in">diff</span> [<span class="type">first</span>-<span class="type">branch</span>]...[<span class="type">second</span>-<span class="type">branch</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示今天你写了多少行代码</span></span><br><span class="line"><span class="variable">$</span> git <span class="built_in">diff</span> <span class="literal">--shortstat</span> <span class="string">&quot;@&#123;0 day ago&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交的元数据和内容变化</span></span><br><span class="line"><span class="variable">$</span> git show [<span class="type">commit</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交发生变化的文件</span></span><br><span class="line"><span class="variable">$</span> git show <span class="literal">--name-only</span> [<span class="type">commit</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交时，某个文件的内容</span></span><br><span class="line"><span class="variable">$</span> git show [<span class="type">commit</span>]:[<span class="type">filename</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的最近几次提交</span></span><br><span class="line"><span class="variable">$</span> git reflog</span><br></pre></td></tr></table></figure>

<h1 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h1><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载远程仓库的所有变动</span></span><br><span class="line"><span class="variable">$</span> git fetch [<span class="type">remote</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有远程仓库</span></span><br><span class="line"><span class="variable">$</span> git remote <span class="literal">-v</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line"><span class="variable">$</span> git remote show [<span class="type">remote</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line"><span class="variable">$</span> git remote add [<span class="type">shortname</span>] [<span class="type">url</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line"><span class="variable">$</span> git pull [<span class="type">remote</span>] [<span class="type">branch</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line"><span class="variable">$</span> git push [<span class="type">remote</span>] [<span class="type">branch</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line"><span class="variable">$</span> git push [<span class="type">remote</span>] <span class="literal">--force</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送所有分支到远程仓库</span></span><br><span class="line"><span class="variable">$</span> git push [<span class="type">remote</span>] <span class="literal">--all</span></span><br></pre></td></tr></table></figure>

<h1 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h1><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 恢复暂存区的指定文件到工作区</span></span><br><span class="line"><span class="variable">$</span> git checkout [<span class="type">file</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line"><span class="variable">$</span> git checkout [<span class="type">commit</span>] [<span class="type">file</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复暂存区的所有文件到工作区</span></span><br><span class="line"><span class="variable">$</span> git checkout .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line"><span class="variable">$</span> git reset [<span class="type">file</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line"><span class="variable">$</span> git reset <span class="literal">--hard</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line"><span class="variable">$</span> git reset [<span class="type">commit</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line"><span class="variable">$</span> git reset <span class="literal">--hard</span> [<span class="type">commit</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line"><span class="variable">$</span> git reset <span class="literal">--keep</span> [<span class="type">commit</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line"><span class="variable">$</span> git revert [<span class="type">commit</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line"><span class="variable">$</span> git stash</span><br><span class="line"><span class="variable">$</span> git stash pop</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>IFormFile始终为空的问题</title>
    <url>/2019/11/04/IFormFile%E5%A7%8B%E7%BB%88%E4%B8%BA%E7%A9%BA%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>  之前获取上传文件都是使用Request.Form.Files获取，直到这次<br>  改成定义形参 IFormFile时才遇到这个问题。  </p>
<span id="more"></span>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// POST api/values</span></span><br><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Post</span>(<span class="params">[FromForm] IFormFile file</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">　　<span class="keyword">var</span> files = Request.Form.Files;</span><br><span class="line">　　<span class="comment">//file == null</span></span><br><span class="line">　　<span class="comment">//files != null;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  不知道这是不是微软的一个BUG？  </p>
<p>  解决方案有两种：</p>
<p>  方案一：去除[ApiController]这个Attribute</p>
  <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="string">&quot;api/[controller]&quot;</span>)</span>]</span><br><span class="line"><span class="comment">//[ApiController]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ValuesController</span> : <span class="title">ControllerBase</span> </span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 方案二：在[FromForm]里添加Name属性:[FromForm(name &#x3D; “file”)]，这个属性需跟file参数保持一致</p>
  <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// POST api/values</span></span><br><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Post</span>(<span class="params">[FromForm(Name = <span class="string">&quot;file&quot;</span></span>)] IFormFile file)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>方案出自：<a href="https://stackoverflow.com/questions/52294830/iformfile-is-always-null-when-receiving-file-from-console-app">IFormFile is always null when receiving file from console app</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>.Netcore</tag>
      </tags>
  </entry>
  <entry>
    <title>JS设置localStorage有效期</title>
    <url>/2018/09/03/JS%E8%AE%BE%E7%BD%AElocalStorage%E6%9C%89%E6%95%88%E6%9C%9F/</url>
    <content><![CDATA[<p>  localStorage是一个没有时间限制的数据存储，如果没有手动删除它，它将永久保存。但是有些时候我们又需要它在一段时间后自动删除，这里我们可以对它进行扩展。</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line"><span class="comment">//设置localStorage的值</span></span><br><span class="line">foowwLocalStorage.<span class="title function_">set</span>(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;你好&quot;</span>, date + <span class="number">10000</span>);</span><br><span class="line"><span class="comment">//获取localStorage的值</span></span><br><span class="line"><span class="keyword">var</span> data = foowwLocalStorage.<span class="title function_">get</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foowwLocalStorage = &#123;</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">key, value, ttl_ms</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> data = &#123; <span class="attr">value</span>: value, <span class="attr">expirse</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(ttl_ms).<span class="title function_">getTime</span>() &#125;;</span><br><span class="line">        <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(key, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data));</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">key</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(key));</span><br><span class="line">        <span class="keyword">if</span> (data !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">debugger</span></span><br><span class="line">            <span class="keyword">if</span> (data.<span class="property">expirse</span> != <span class="literal">null</span> &amp;&amp; data.<span class="property">expirse</span> &lt; <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()) &#123;</span><br><span class="line">                <span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> data.<span class="property">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常用命令</title>
    <url>/2018/04/12/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><strong>Linux中常用的一些命令，记录下来方便日后查询(持续更新中…)</strong></p>
<span id="more"></span>

<p>查看端口使用情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -ntpl #查看端口使用情况</span><br><span class="line"></span><br><span class="line">#查看所有端口</span><br><span class="line">netstat -aptn</span><br><span class="line">#方式测试远程主机端口是否打开</span><br><span class="line">telnet ip 端口号 </span><br></pre></td></tr></table></figure>

<p>删除文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm</span><br><span class="line">rm-rf //删除文件夹所以文件  </span><br></pre></td></tr></table></figure>
<p>查看系统版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/version</span><br></pre></td></tr></table></figure>
<p>查看所有监听端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -Intp</span><br></pre></td></tr></table></figure>
<p>重启Nginx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service nginx restart</span><br></pre></td></tr></table></figure>
<p>重启FTP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service vsftpd restart</span><br></pre></td></tr></table></figure>
<p>添加账号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo adduser xxx //home目录下添加一个账号</span><br></pre></td></tr></table></figure>
<p>添加用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo useradd xxx //添加用户，不在home目录添加账号</span><br></pre></td></tr></table></figure>
<p>删除账户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">userdel -r xxx //加上r删除用户目录</span><br></pre></td></tr></table></figure>
<p>查看当前系统用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat etc/passwd</span><br></pre></td></tr></table></figure>
<p>文件&#x2F;文件夹命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//CP命令</span><br><span class="line">//格式：CP [选项] 源文件或目录 目的文件或目录</span><br><span class="line">//选项说明：-b:同名，备份原来文件  -f 强制覆盖同名文件  -r 按递归方式保留原目录结构复制文件</span><br><span class="line">cp -r /tmp/a /root/a</span><br><span class="line"></span><br><span class="line">//MV 移动</span><br><span class="line"></span><br><span class="line">//解压tag.gz</span><br><span class="line">tar -zxvf ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>开启防火墙端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=10050/tcp </span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<p>解压</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#tar.gz</span><br><span class="line">tar -zxvf ...</span><br><span class="line">#7z</span><br><span class="line">7za x ...</span><br></pre></td></tr></table></figure>

<p>vim输入：ins或i，wq保存，u撤销，ctrl+u取消撤销 q!退出</p>
<p>软件相关</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">删除某软件</span><br><span class="line">删除安装包</span><br><span class="line">sudo apt-get remove zabbix-agent</span><br><span class="line">删除相关从属安装包</span><br><span class="line">sudo apt-get remove --auto-remove zabbix-agent</span><br><span class="line">清理相关配置文件</span><br><span class="line">sudo apt-get purge zabbix-agent</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>System</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习笔记-Python数据类型</title>
    <url>/2018/03/27/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>  字符串格式化: 用 % 实现<br>  可使用 isinstance(x, str) 判断变量x是否是字符串  </p>
<span id="more"></span>

  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  &gt;&gt;&gt; &#x27;Hello , %s&#x27; % &#x27;world&#x27;</span><br><span class="line">&#x27;Hello , world&#x27;</span><br><span class="line">&gt;&gt;&gt; &#x27;Hi , %s , you have $%d.&#x27; % (&#x27;Michael&#x27; , 1000000)</span><br><span class="line">&#x27;Hi , Michael , you have $1000000.&#x27;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>占位符</th>
<th>替换内容</th>
</tr>
</thead>
<tbody><tr>
<td>%d</td>
<td>整数</td>
</tr>
<tr>
<td>%f</td>
<td>浮点数</td>
</tr>
<tr>
<td>%s</td>
<td>字符串</td>
</tr>
<tr>
<td>%x</td>
<td>十六进制整数</td>
</tr>
</tbody></table>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>  有序集合，可随时添加和删除其中的元素。<br>  有两个特点：  </p>
<ul>
<li>查找和插入的时间随着元素的增加而增加</li>
<li>占用空间小，浪费内存少<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates = [&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]</span><br></pre></td></tr></table></figure>
使用 len() 函数获取长度，最后一位元素是 len(classmates) -1<br>追加元素使用 append() ，插入元素使用 insert()，删除末尾使用 pop()，删除指定 pop(1)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates.append(&#x27;Adam&#x27;)</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;, &#x27;Adam&#x27;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; classmates.insert(1, &#x27;Jack&#x27;)</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&#x27;Michael&#x27;, &#x27;Jack&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;, &#x27;Adam&#x27;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; classmates.pop()</span><br><span class="line">&#x27;Adam&#x27;</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&#x27;Michael&#x27;, &#x27;Jack&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; classmates.pop()</span><br><span class="line">&#x27;Adam&#x27;</span><br><span class="line">&gt;&gt;&gt; classmates</span><br><span class="line">[&#x27;Michael&#x27;, &#x27;Jack&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]</span><br></pre></td></tr></table></figure>

<h3 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h3><p>有序列表元组，与list类似，但初始化后不能修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates = (&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;)</span><br></pre></td></tr></table></figure>
<p>如果只有一个元素，需要加上一个逗号避免歧义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1,)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(1,)</span><br></pre></td></tr></table></figure>

<h3 id="Dict"><a href="#Dict" class="headerlink" title="Dict"></a>Dict</h3><p>字典，全称dictionary，使用键值对(key , value)存储</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;&#x27;Michael&#x27;: 95, &#x27;Bob&#x27;: 75, &#x27;Tracy&#x27;: 85&#125;</span><br><span class="line">&gt;&gt;&gt; d[&#x27;Michael&#x27;]</span><br><span class="line">95</span><br></pre></td></tr></table></figure>

<p>使用 in 判断 key 是否存在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;Thomas&#x27; in d</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>使用 get() ，如果 key 不存在，可以返回 None，或者指定的value</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; d.get(&#x27;Thomas&#x27;)</span><br><span class="line">&gt;&gt;&gt; d.get(&#x27;Thomas&#x27;, -1)</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>

<p>删除一个 key ，对应的 value 也会删除，使用 pop(key) </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; d.pop(&#x27;Bob&#x27;)</span><br><span class="line">75</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;Michael&#x27;: 95, &#x27;Tracy&#x27;: 85&#125;</span><br></pre></td></tr></table></figure>
<p>和List相比，有两个特点:</p>
<ul>
<li>查找和插入速度快，不会随着key的增加而变慢</li>
<li>需要占用大量内存，浪费内存多</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>与 dict 类似，但仅存储 key，不存储value，且key不可以重复</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure>
<p>通过 add(key) 添加元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s.add(4)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br><span class="line">&gt;&gt;&gt; s.add(4)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure>
<p>通过 remove(key) 删除元素</p>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu部署netcore网站</title>
    <url>/2020/03/15/Ubuntu%E9%83%A8%E7%BD%B2netcore%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<p>Docker部署netcore网站，并使用Docker nginx 作为正向代理；</p>
<span id="more"></span>

<p>创建测试项目后，修改网站监听端口，具体设置方式请查阅另一篇博文《Ubuntu部署Asp.net core网站无法访问》</p>
<p>上传publish文件到Linux，创建文件Dockerfile，编辑内容为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM mcr.microsoft.com/dotnet/core/aspnet //从该镜像拉取</span><br><span class="line">WORKDIR /app  //工作目录</span><br><span class="line">COPY . .  </span><br><span class="line">EXPOSE 80 //容器对外开放端口</span><br><span class="line">CMD [<span class="string">&quot;dotnet&quot;</span>, <span class="string">&quot;website.dll&quot;</span>] //执行命令</span><br></pre></td></tr></table></figure>

<p>把网站打包成镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t website .</span><br></pre></td></tr></table></figure>

<p>创建并运行容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name website -p 8080:80 -d website</span><br></pre></td></tr></table></figure>

<p>至此，网站已成功发布。使用ip:port即可访问网站。</p>
<p>接下来使用docker拉取nginx</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>

<p>在创建nginx容器前先创建好挂载目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> var</span><br><span class="line"><span class="built_in">mkdir</span> nginx</span><br><span class="line"><span class="built_in">cd</span> nginx</span><br><span class="line"><span class="built_in">mkdir</span> www conf logs</span><br></pre></td></tr></table></figure>

<p>进入conf文件夹，创建并编辑nginx.conf配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> conf</span><br><span class="line">vim nginx.conf</span><br></pre></td></tr></table></figure>

<p>nginx.conf文件内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">user nginx;</span><br><span class="line"><span class="comment"># 运行用户，默认是nginx</span></span><br><span class="line">worker_processes auto;</span><br><span class="line"><span class="comment"># nginx进程数,一般设置为和cpu核数一样</span></span><br><span class="line">error_log /var/log/nginx/error.log;</span><br><span class="line"><span class="comment"># 全局错误日志路径</span></span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line"><span class="comment"># 进程pid路径</span></span><br><span class="line"><span class="comment"># Load dynamic modules. See /usr/share/nginx/README.dynamic.</span></span><br><span class="line"><span class="comment"># 负载动态模块</span></span><br><span class="line">include /usr/share/nginx/modules/*.conf;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line"><span class="comment"># 工作模式与连接数上限</span></span><br><span class="line">    worker_connections 1024;</span><br><span class="line">   <span class="comment"># 单个进程的最大连接数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line"><span class="comment"># 设置http服务器</span></span><br><span class="line">    log_format  main  <span class="string">&#x27;$http_host $server_addr $remote_addr [$time_local] &quot;$request&quot; $status  $request_body  $body_bytes_sent &quot;$http_referer&quot; &quot;$http_user_agent&quot; $request_time $upstream_response_time&#x27;</span>;</span><br><span class="line">    <span class="comment"># 设置日志的格式</span></span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line">    <span class="comment"># 访问日志的路径</span></span><br><span class="line"></span><br><span class="line">    sendfile            on;</span><br><span class="line">    <span class="comment"># 开启高效传输模式</span></span><br><span class="line">    tcp_nopush          on;</span><br><span class="line">    <span class="comment"># 激活tcp_nopush参数可以允许把http response header和文件的开始放在一个文件里发布，作用是减少网络报文段的数量</span></span><br><span class="line">    tcp_nodelay         on;</span><br><span class="line">    <span class="comment"># 激活tcp_nodelay，内核会等待将更多的字节组成一个数据包，从而提高I/O性能</span></span><br><span class="line">    keepalive_timeout   65;</span><br><span class="line">    <span class="comment"># 长连接超时时间，单位是秒</span></span><br><span class="line">    types_hash_max_size 2048;</span><br><span class="line">    <span class="comment"># 为了快速处理静态数据集，例如服务器名称， 映射指令的值，MIME类型，请求头字符串的名称，nginx使用哈希表</span></span><br><span class="line"></span><br><span class="line">    include             /etc/nginx/mime.types;</span><br><span class="line">    <span class="comment"># 文件扩展名与类型映射表</span></span><br><span class="line">    default_type        application/octet-stream;</span><br><span class="line">    <span class="comment"># 默认文件类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load modular configuration files from the /etc/nginx/conf.d directory.</span></span><br><span class="line">    <span class="comment"># 加载模块化配置文件</span></span><br><span class="line">    <span class="comment"># See http://nginx.org/en/docs/ngx_core_module.html#include</span></span><br><span class="line">    <span class="comment"># for more information.</span></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">    <span class="comment"># 基于域名的虚拟主机</span></span><br><span class="line">        listen       80 default_server;</span><br><span class="line">        <span class="comment"># 监听端口</span></span><br><span class="line">        listen       [::]:80 default_server;</span><br><span class="line">        server_name  _;</span><br><span class="line">        <span class="comment"># 域名</span></span><br><span class="line">        <span class="comment">#root         /usr/share/nginx/html;</span></span><br><span class="line">        <span class="comment"># 站点根目录，即网站程序存放目录</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line">        <span class="comment"># 默认服务器块的加载配置文件</span></span><br><span class="line">        include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://ip:8080;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html;</span><br><span class="line">            location = /40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html;</span><br><span class="line">            location = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建并运行容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 80:80 --name blog -v <span class="variable">$PWD</span>/www:/usr/share/nginx/html -v <span class="variable">$PWD</span>/conf/nginx.conf:/etc/nginx/nginx.conf -v <span class="variable">$PWD</span>/logs:/var/log/nginx nginx</span><br></pre></td></tr></table></figure>

<p>Nginx部署完成，此刻直接输入ip可直接访问网站。</p>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>.Netcore</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker命令</title>
    <url>/2020/03/15/Docker%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>docker 常用命令</p>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images <span class="comment">#输出所有镜像</span></span><br><span class="line">docker rmi image_id <span class="comment">#移除某镜像</span></span><br><span class="line">docker ps <span class="comment">#查看正在运行的容器</span></span><br><span class="line">docker ps -a <span class="comment">#查看所有容器</span></span><br><span class="line"></span><br><span class="line">停用全部运行中的容器:docker stop $(docker ps -q)</span><br><span class="line">删除全部容器：docker <span class="built_in">rm</span> $(docker ps -aq)</span><br><span class="line">一条命令实现停用并删除容器 docker stop $(docker ps -q) &amp; docker <span class="built_in">rm</span> $(docker ps -aq)</span><br><span class="line"></span><br><span class="line">修改时区：docker <span class="built_in">cp</span> /usr/share/zoneinfo/Asia/Shanghai 容器<span class="built_in">id</span>:/etc/localtime</span><br><span class="line"></span><br><span class="line">管理命令： </span><br><span class="line">container 管理容器 </span><br><span class="line">image 管理镜像 </span><br><span class="line">network 管理网络 </span><br><span class="line">node 管理Swarm节点 </span><br><span class="line">plugin 管理插件 </span><br><span class="line">secret 管理Docker secrets </span><br><span class="line">service 管理服务 </span><br><span class="line">stack 管理Docker stacks </span><br><span class="line">swarm 管理Swarm集群 </span><br><span class="line">system 查看系统信息 </span><br><span class="line">volume 管理卷 </span><br><span class="line">如：docker container <span class="built_in">ls</span> 显示所有容器 </span><br><span class="line"></span><br><span class="line">普通命令： </span><br><span class="line">Docker <span class="built_in">exec</span> -it containerId /bin/bash 进入容器</span><br><span class="line">以root角色进入 ddocker <span class="built_in">exec</span> -it -u root containerId /bin/bash</span><br><span class="line"></span><br><span class="line">build 从一个DockerFile构建镜像 </span><br><span class="line">commit 从容器创建一个镜像 </span><br><span class="line"><span class="built_in">cp</span> 从容器和主机文件系统之间拷贝文件 </span><br><span class="line">create 创建一个容器 </span><br><span class="line">diff 检查容器文件系统上的更改</span><br><span class="line">events 从服务器获取实时事件 </span><br><span class="line"><span class="built_in">exec</span> 在正在运行的容器中运行命令 </span><br><span class="line"><span class="built_in">export</span> 将容器的文件系统导出为tar存档 </span><br><span class="line"><span class="built_in">history</span> 显示镜像的历史记录 </span><br><span class="line">images 查看镜像列表 </span><br><span class="line">import 从归档文件中创建镜像 </span><br><span class="line">info 显示系统范围的信息 </span><br><span class="line">inspect 返回Docker对象的低级信息 </span><br><span class="line"><span class="built_in">kill</span> <span class="built_in">kill</span>运行中的容器 </span><br><span class="line">load 从存档或者STDIN加载镜像 </span><br><span class="line">login 登陆docker镜像仓库 </span><br><span class="line"><span class="built_in">logout</span> 退出docker镜像仓库 </span><br><span class="line">logs 获取一个容器的日志 </span><br><span class="line">pause 暂停一个或多个容器中的所有进程 </span><br><span class="line">port 查看端口映射或容器的特定映射列表 </span><br><span class="line">ps 查看容器列表 </span><br><span class="line">pull 从镜像仓库拉取镜像 </span><br><span class="line">push 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库</span><br><span class="line">rename 重命名容器 </span><br><span class="line">restart 重启容器 </span><br><span class="line"><span class="built_in">rm</span> 删除容器 </span><br><span class="line">rmi 删除镜像 </span><br><span class="line">run 创建一个新的容器并运行一个命令</span><br><span class="line">save 将指定镜像保存成 </span><br><span class="line">tar 归档文件 </span><br><span class="line">search 从Docker Hub搜索镜像 </span><br><span class="line">start 启动容器 </span><br><span class="line">stats 实时显示容器资源使用情况的统计信息</span><br><span class="line">stop 停止容器 </span><br><span class="line">tag 标记本地镜像，将其归入某一仓库</span><br><span class="line">top 展示一个容器中运行的进程 </span><br><span class="line">unpause 恢复容器中所有的进程 </span><br><span class="line">update 更新容器配置 </span><br><span class="line">version 显示Docker的版本信息 </span><br><span class="line"><span class="built_in">wait</span> 阻塞直到容器停止，然后打印退出代码 </span><br><span class="line">如：docker images 显示所有镜像</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Webbench的使用</title>
    <url>/2018/09/03/Webbench%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>  Webbench是一个在linux下使用的非常简单的网站压测工具。它使用fork()模拟多个客户端同时访问我们设定的URL，测试网站在压力下工作的性能，最多可以模拟3万个并发连接去测试网站的负载能力。  </p>
<p>  下载好tar.gz文件，上传到linux。  </p>
<span id="more"></span>

<ul>
<li>编译安装<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@ip:/home/ftp/webbench-1.5# make install</span><br><span class="line">cc -Wall -ggdb -W -O  -o webbench webbench.o  </span><br><span class="line">install -s webbench /usr/local/bin    </span><br><span class="line">install -m 644 webbench.1 /usr/local/man/man1    </span><br><span class="line">install -d /usr/local/share/doc/webbench</span><br><span class="line">install -m 644 debian/copyright /usr/local/share/doc/webbench</span><br><span class="line">install -m 644 debian/changelog /usr/local/share/doc/webbench</span><br></pre></td></tr></table></figure></li>
<li>使用<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@ip:/home/ftp/webbench-1.5# webbench -c 100 http://fedupapi.azurewebsites.net/</span><br><span class="line">Webbench - Simple Web Benchmark 1.5</span><br><span class="line">Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software.</span><br><span class="line"></span><br><span class="line">Benchmarking: GET http://fedupapi.azurewebsites.net/</span><br><span class="line">100 clients, running 30 sec.</span><br><span class="line"></span><br><span class="line">Speed=10854 pages/min, 76339 bytes/sec.</span><br><span class="line">Requests: 5427 susceed, 0 failed.</span><br></pre></td></tr></table></figure></li>
</ul>
<p>如果执行 make install 出错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xx@xx:~/WebBench$ make install</span><br><span class="line">cc -Wall -ggdb -W -O   -c -o webbench.o webbench.c</span><br><span class="line">webbench.c: In function ‘alarm_handler’:</span><br><span class="line">webbench.c:80:31: warning: unused parameter ‘signal’ [-Wunused-parameter]</span><br><span class="line">static void alarm_handler(int signal)</span><br></pre></td></tr></table></figure>

<p>解决方案(WebBench 依赖 ctags)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ctags </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>Zabbix部署和简单使用</title>
    <url>/2020/04/11/Zabbix%E9%83%A8%E7%BD%B2%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><strong>Zabbix部署和简单使用</strong></p>
<p>  使用Docker容器部署Zabbix，并添加Windows和Linux服务器监测节点。</p>
<span id="more"></span>

<h2 id="Zabbix是什么"><a href="#Zabbix是什么" class="headerlink" title="Zabbix是什么"></a>Zabbix是什么</h2><p>Zabbix是一种网络监视、管理系统，基于Server-Client架构。可用于监视各种网络服务、服务器和网络机器等状态。</p>
<p>可以监控如下资源</p>
<p><img src="https://s1.ax1x.com/2020/04/11/GbhL4J.png"></p>
<h2 id="为什么要监控？"><a href="#为什么要监控？" class="headerlink" title="为什么要监控？"></a>为什么要监控？</h2><ol>
<li>在需要的时刻，提前提醒我们服务器出问题了</li>
<li>当出问题之后，可以找到问题根源</li>
<li>实时观测网站&#x2F;服务器的可用性</li>
</ol>
<h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><p>分为主动模式和被动模式</p>
<ol>
<li>主动模式：客户端主动把自己监测到的数据上报给服务端，服务端不需要向客户端发起请求</li>
</ol>
<p><img src="https://s1.ax1x.com/2020/04/11/Gbh7HU.png"></p>
<ol start="2">
<li><p>被动模式：服务端向客户端发起请求，告诉客户端我需要哪些数据，然后客户端执行相关操作，把执行结果返回给服务端</p>
<p><img src="https://s1.ax1x.com/2020/04/11/GbhTBT.png"></p>
</li>
</ol>
<h2 id="自动发现与自动注册"><a href="#自动发现与自动注册" class="headerlink" title="自动发现与自动注册"></a>自动发现与自动注册</h2><ol>
<li><p>自动发现：zabbix主动发现所有客户端，扫描设定的IP段。缺点是压力大，时间长</p>
</li>
<li><p>自动注册：zabbix agent主动到zabbix Server上报到，登记；缺点agent有可能找不到Server（配置出错）</p>
<p>自动注册配置：</p>
<p><img src="https://s1.ax1x.com/2020/04/11/GbLdZn.png"></p>
<p><img src="https://s1.ax1x.com/2020/04/11/GbLNrj.png"></p>
<p><img src="https://s1.ax1x.com/2020/04/11/GbLtMQ.png"></p>
<p><img src="https://s1.ax1x.com/2020/04/11/GbLUqs.png"></p>
<p><img src="https://s1.ax1x.com/2020/04/11/GbLwaq.png"></p>
</li>
</ol>
<h2 id="使用Docker安装Zabbix服务端"><a href="#使用Docker安装Zabbix服务端" class="headerlink" title="使用Docker安装Zabbix服务端"></a>使用Docker安装Zabbix服务端</h2><p>安装必须组件 mysql5.7、zabbix-server-mysql和zabbix-web-nginx-mysql</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启动mysql5.7实例</span><br><span class="line">docker run --name mysql-server -t -v /etc/timezone:/etc/timezone -v /etc/localtime:/etc/localtime  -v /data/mysql5.7/data:/var/lib/mysql -v /data/mysql/etc:/etc/mysql/conf.d   -e MYSQL_DATABASE=&quot;zabbix&quot;       -e MYSQL_USER=&quot;zabbix&quot;       -e MYSQL_PASSWORD=&quot;zabbix&quot;       -e MYSQL_ROOT_PASSWORD=&quot;zabbix&quot;       -d mysql:5.7  --character-set-server=utf8 --collation-server=utf8_bin</span><br><span class="line"></span><br><span class="line"># 启动Zabbix server实例，并关联这个实例到已创建的MySQL服务器实例</span><br><span class="line">docker run --name zabbix-server-mysql -t  -e PHP_TZ=&quot;Asia/Shanghai&quot; -v /etc/timezone:/etc/timezone  -v /etc/localtime:/etc/localtime   -e DB_SERVER_HOST=&quot;mysql-server&quot;       -e MYSQL_DATABASE=&quot;zabbix&quot;       -e MYSQL_USER=&quot;zabbix&quot;       -e MYSQL_PASSWORD=&quot;zabbix&quot;       -e MYSQL_ROOT_PASSWORD=&quot;zabbix&quot;       --link mysql-server:mysql       -p 10051:10051       -d zabbix/zabbix-server-mysql:latest</span><br><span class="line"></span><br><span class="line"># 启动Zabbix web 接口，并将它与MySQL服务器实例和Zabbix server实例关联</span><br><span class="line">docker run --name zabbix-web-nginx-mysql -t -e PHP_TZ=&quot;Asia/Shanghai&quot; -v /etc/timezone:/etc/timezone  -v /etc/localtime:/etc/localtime     -e DB_SERVER_HOST=&quot;mysql-server&quot;       -e MYSQL_DATABASE=&quot;zabbix&quot;       -e MYSQL_USER=&quot;zabbix&quot;       -e MYSQL_PASSWORD=&quot;zabbix&quot;       -e MYSQL_ROOT_PASSWORD=&quot;zabbix&quot;       --link mysql-server:mysql       --link zabbix-server-mysql:zabbix-server       -p 80:80       -d zabbix/zabbix-web-nginx-mysql:latest</span><br></pre></td></tr></table></figure>

<p>修改每个容器时区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker cp /usr/share/zoneinfo/Asia/Shanghai containerId:/etc/localtime</span><br></pre></td></tr></table></figure>

<p>解决中文乱码问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#找到字体所位置</span><br><span class="line">find -name DejaVuSans.ttf</span><br><span class="line">拷贝Windows下的C:\Windows\Fonts 宋体字体 到docker里</span><br><span class="line">随后备份DejaVuSans.ttf字体，并更名宋体为DejaVuSans.ttf，刷新页面可看到效果</span><br></pre></td></tr></table></figure>

<h2 id="添加服务器"><a href="#添加服务器" class="headerlink" title="添加服务器"></a>添加服务器</h2><p><strong>添加一台Windows服务器</strong></p>
<p>客户端操作：</p>
<p><a href="https://www.zabbix.com/cn/download_agents">下载Zabbix Agent客户端</a>，并安装到被监测的主机上</p>
<p>Server和ServerActive均设置为监控服务器的IP</p>
<p>若Zabbix服务器在内网，被监控对象在外网，则需要拿到监控服务端的外网IP。</p>
<p>如何获取外网IP？</p>
<p>先在zabbix服务器使用telnet命令连客户端的10050端口，然后在客户端使用netstat -an | grep 10050查看被那个IP访问了。</p>
<p>Web操作：</p>
<ol>
<li><p>进入页面：【配置】-&gt;【主机】-&gt;【创建主机】</p>
<p><img src="https://s1.ax1x.com/2020/04/11/GbTKQs.png"></p>
</li>
<li><p>必填主机名、群组选择Templates&#x2F;Operating systems，agent代理程序的ip地址填被监控主机ip，端口不变为10050。</p>
<p><img src="https://s1.ax1x.com/2020/04/11/GbTmWQ.png"></p>
</li>
<li><p>选择Tab【模板】，选中Template OS Windows By zabbix agent</p>
<p><img src="https://s1.ax1x.com/2020/04/11/GbTnzj.png"></p>
</li>
<li><p>点击底部添加按钮，回到主机列表页</p>
<p><img src="https://s1.ax1x.com/2020/04/11/GbTeJg.png"></p>
</li>
</ol>
<p><strong>添加一台Linux服务器</strong></p>
<p>客户端操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#关闭SELinux (如果有)</span><br><span class="line">sed -i &quot;s/SELINUX=enforcing/SELINUX=disabled/&quot; /etc/selinux/config</span><br><span class="line">setenforce 0</span><br><span class="line">#防火墙设置，允许zabbix-agent的10050端口通过</span><br><span class="line">firewall-cmd --permanent --add-port=10050/tcp</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">#下载安装包并安装(Centos)</span><br><span class="line">rpm -Uvh https://repo.zabbix.com/zabbix/4.4/rhel/7/x86_64/zabbix-release-4.4-1.el7.noarch.rpm</span><br><span class="line">yum install zabbix-agent</span><br><span class="line">#下载安装包并安装(Ubuntu)</span><br><span class="line">wget http://repo.zabbix.com/zabbix/4.4/ubuntu/pool/main/z/zabbix-release/zabbix-release_4.4-1+bionic_all.deb</span><br><span class="line">dpkg -i zabbix-release_4.4-1+bionic_all.deb</span><br><span class="line">apt update</span><br><span class="line">apt install zabbix-agent</span><br><span class="line">#安装完以后找到配置文件</span><br><span class="line">find -name &#x27;zabbix*&#x27;</span><br><span class="line">#修改内容：</span><br><span class="line">Server=&lt;zbx-server的ip&gt;</span><br><span class="line">ServerActive=&lt;zbx-server的ip&gt;</span><br><span class="line">Hostname=&lt;本机名字&gt;</span><br><span class="line">#启动agent</span><br><span class="line">systemctl start zabbix-agent.service</span><br><span class="line">systemctl status zabbix-agent.service</span><br></pre></td></tr></table></figure>

<p>Web操作同添加Windows</p>
<h2 id="添加MYSQL"><a href="#添加MYSQL" class="headerlink" title="添加MYSQL"></a>添加MYSQL</h2><p>客户端操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建一个mysql用户</span><br><span class="line">GRANT ALL ON . TO &#x27;zbx_monitor&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;zbx_monitor&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line">#在zabbix_agentd服务目录下创建my.cnf</span><br><span class="line">目前我使用的是windows系统，zabbix_agentd安装在C盘，故而在C盘顶层创建，内容为：</span><br><span class="line">[client]</span><br><span class="line">user=zbx_monitor</span><br><span class="line">password=zbx_monitor</span><br><span class="line"></span><br><span class="line">#Zabbix_agentd目录下的zabbix_agentd.conf.d增加一个配置文件,内容为：</span><br><span class="line"></span><br><span class="line">#template_db_mysql.conf created by Zabbix for &quot;Template DB MySQL&quot; and Zabbix 4.2</span><br><span class="line">#For OS Linux: You need create .my.cnf in zabbix-agent home directory (/etc/zabbix by default)</span><br><span class="line">#For OS Windows: You need add PATH to mysql and mysqladmin and create my.cnf in %WINDIR%\my.cnf,C:\my.cnf,BASEDIR\my.cnf https://dev.mysql.com/doc/refman/5.7/en/option-files.html</span><br><span class="line">#The file must have three strings:</span><br><span class="line">#[client]</span><br><span class="line">#user=zbx_monitor</span><br><span class="line">#password=&lt;password&gt;</span><br><span class="line">UserParameter=mysql.ping[*], mysqladmi</span><br><span class="line">UserParameter=mysql.get_status_variables[*], mysql -h&quot;$1&quot; -P&quot;$2&quot; -sNX -e &quot;show global status&quot;</span><br><span class="line">UserParameter=mysql.version[*], mysqladmin -s -h&quot;$1&quot; -P&quot;$2&quot; version</span><br><span class="line">UserParameter=mysql.db.discovery[*], mysql -h&quot;$1&quot; -P&quot;$2&quot; -sN -e &quot;show databases&quot;</span><br><span class="line">UserParameter=mysql.dbsize[*], mysql -h&quot;$1&quot; -P&quot;$2&quot; -sN -e &quot;SELECT SUM(DATA_LENGTH + INDEX_LENGTH) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA=&#x27;$3&#x27;&quot;</span><br><span class="line">UserParameter=mysql.replication.discovery[*], mysql -h&quot;$1&quot; -P&quot;$2&quot; -sNX -e &quot;show slave status&quot;</span><br><span class="line">UserParameter=mysql.slave_status[*], mysql -h&quot;$1&quot; -P&quot;$2&quot; -sNX -e &quot;show slave status&quot;</span><br><span class="line"></span><br><span class="line">修改zabbix_agentd.conf,添加内容：</span><br><span class="line">Include=C:\Program Files\Zabbix Agent\zabbix_agentd.conf.d\*.conf</span><br><span class="line"></span><br><span class="line">重启zabbix_agent服务</span><br><span class="line"></span><br><span class="line">#到zabbix_mysql_server 监控主机测试mysql命令</span><br><span class="line">zabbix_get -s ip -p 10050 -k mysql.ping</span><br></pre></td></tr></table></figure>

<p>Web操作：</p>
<p>选择MYSQL所在主机</p>
<p><img src="https://s1.ax1x.com/2020/04/11/GbbalQ.png"></p>
<p><img src="https://s1.ax1x.com/2020/04/11/Gbbdyj.png"></p>
<h2 id="添加网站"><a href="#添加网站" class="headerlink" title="添加网站"></a>添加网站</h2><p><img src="https://s1.ax1x.com/2020/04/11/GbqBge.png"></p>
<p><img src="https://s1.ax1x.com/2020/04/11/GbqDjH.png"></p>
<p><img src="https://s1.ax1x.com/2020/04/11/Gbqsud.png"></p>
]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>O&amp;M</tag>
      </tags>
  </entry>
  <entry>
    <title>上传本地项目到GitHub</title>
    <url>/2018/04/12/%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E5%88%B0GitHub/</url>
    <content><![CDATA[<ol>
<li>生成ssh秘钥<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;xxxx@xx.com&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>

<ol start="2">
<li><p>登录github，打开Account Settings ,选择 SSH Public Keys ，添加 ...ssh\id_rsa.pub 的内容</p>
</li>
<li><p>设置用户信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;fuquanli&quot;    //设置用户名</span><br><span class="line">git config --global user.email &quot;fuquan.li@qq.com&quot;    //设置邮箱</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试连接 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立本地仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd d:text</span><br><span class="line">git init</span><br></pre></td></tr></table></figure>
</li>
<li><p>将所有文件添加到仓库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;提交文件&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关联github仓库<br>  复制项目地址后执行  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin [项目地址]</span><br></pre></td></tr></table></figure>
</li>
<li><p>上传本地仓库代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>关于IoC和DI</title>
    <url>/2018/04/12/%E5%85%B3%E4%BA%8EIoC%E5%92%8CDI/</url>
    <content><![CDATA[<h1 id="IoC：Inversion-of-Control（控制反转）"><a href="#IoC：Inversion-of-Control（控制反转）" class="headerlink" title="IoC：Inversion of Control（控制反转）"></a>IoC：Inversion of Control（控制反转）</h1><h2 id="谁控制谁？"><a href="#谁控制谁？" class="headerlink" title="谁控制谁？"></a>谁控制谁？</h2><pre><code> IoC容器控制对象的创建，也就是IoC容器控制对象
</code></pre>
<h2 id="控制了什么？"><a href="#控制了什么？" class="headerlink" title="控制了什么？"></a>控制了什么？</h2><pre><code> 控制了外部资源的获取（如对象、文件等）
</code></pre>
<h2 id="正转和反转："><a href="#正转和反转：" class="headerlink" title="正转和反转："></a>正转和反转：</h2><pre><code> 正转：如在传统应用程序里，我们主动去new对象
 反转：容器创建对注入依赖对象
</code></pre>
<h2 id="为什么是反转？"><a href="#为什么是反转？" class="headerlink" title="为什么是反转？"></a>为什么是反转？</h2><pre><code> 因为是容器帮助我们查找并注入依赖对象
</code></pre>
<span id="more"></span>

<h1 id="DI：Dependency-Injection（依赖注入）"><a href="#DI：Dependency-Injection（依赖注入）" class="headerlink" title="DI：Dependency Injection（依赖注入）"></a>DI：Dependency Injection（依赖注入）</h1><p>由容器动态地将某个依赖关系注入到组件之中</p>
<p>依赖注入（Dependency Injection），是这样一个过程：由于某客户类只依赖于服务类的一个接口，而不依赖于具体服务类，所以客户类只定义一个注入点。在程序运行过程中，客户类不直接实例化具体服务类实例，而是客户类的运行上下文环境或专门组件负责实例化服务类，然后将其注入到客户类中，保证客户类的正常运行。</p>
<h2 id="谁依赖谁？"><a href="#谁依赖谁？" class="headerlink" title="谁依赖谁？"></a>谁依赖谁？</h2><pre><code> 应用程序依赖容器
</code></pre>
<h2 id="为什么需要依赖？"><a href="#为什么需要依赖？" class="headerlink" title="为什么需要依赖？"></a>为什么需要依赖？</h2><pre><code> 应用程序需要IoC容器来提供对象需要的外部资源
</code></pre>
<h2 id="谁注入谁？"><a href="#谁注入谁？" class="headerlink" title="谁注入谁？"></a>谁注入谁？</h2><pre><code> IoC容器注入应用程序某个对象，应用程序依赖的对象
</code></pre>
<h2 id="注入了什么？"><a href="#注入了什么？" class="headerlink" title="注入了什么？"></a>注入了什么？</h2><pre><code> 注入了某个对象所需要的外部资源（包括对象、资源、常量数据等）
</code></pre>
<p>依赖注入明确描述了被注入对象依赖IoC容器配置依赖对象</p>
<h2 id="依赖注入三种方式"><a href="#依赖注入三种方式" class="headerlink" title="依赖注入三种方式"></a>依赖注入三种方式</h2><pre><code> 1.构造函数注入：在构造函数种借助参数将依赖的对象注入到创建的对象种
 2.属性注入：通过添加Injection Attribute特性的方式将属性设置为自动注入属性
 3.方法注入：通过调用方法实现对字段(对象)或属性(对象)的初始化
</code></pre>
<h2 id="依赖原则"><a href="#依赖原则" class="headerlink" title="依赖原则"></a>依赖原则</h2><pre><code> 1.高层次模块不应该依赖于低层次模块，它们都应该依赖抽象
 2.抽象不应该依赖具体，具体应该依赖抽象
</code></pre>
<p><a href="http://www.cnblogs.com/leoo2sk/archive/2009/06/17/1504693.html">引用：依赖注入那些事</a></p>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>利用反射把查询到的Table、Reader转换成List、Model</title>
    <url>/2018/04/12/%E5%88%A9%E7%94%A8%E5%8F%8D%E5%B0%84%E6%8A%8A%E6%9F%A5%E8%AF%A2%E5%88%B0%E7%9A%84Table%E3%80%81Reader%E8%BD%AC%E6%8D%A2%E6%88%90List%E3%80%81Model/</url>
    <content><![CDATA[<p>纯粹写着玩，在不使用ORM工具的情况下通过反正转换类型。</p>
<span id="more"></span>

<p>通常我们从数据库查询到一个  DataReader  或者是  一个 Table , 想要转换成 一个 list 或者是<br>一个model 的话 , 一般情况下是使用foreach 循环reader或是table的rows，然后在循环内创建个对象，通过reader[“列名”]来赋值对象的属性。如果表的字段少的话，用这种方式还可以，速度也快一点。但是如果后续还会增加字段的话，那就非常麻烦了，要改很多地方。工作量太大，而且还很容易出错。所以这个时候使用反射来转换的话就非常便捷了。我们只管增加字段，改一下数据表对应的model，调用这个工具类的方法，传入相对应的参数就能得到想要的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static List&lt;T&gt; ConvertToList&lt;T&gt;(DataTable dt)</span><br><span class="line">&#123;</span><br><span class="line">    List&lt;T&gt; list = new List&lt;T&gt;(); // 定义集合</span><br><span class="line">    Type type = typeof(T); // 获得此模型的类型</span><br><span class="line">    string tempName = &quot;&quot;;</span><br><span class="line">    PropertyInfo[] propertys = type.GetProperties();// 获得此模型的公共属性</span><br><span class="line">    foreach (DataRow dr in dt.Rows)</span><br><span class="line">    &#123;</span><br><span class="line">        //新建一个模型</span><br><span class="line">        object obj = type.Assembly.CreateInstance(type.FullName);</span><br><span class="line">        foreach (PropertyInfo pi in propertys)</span><br><span class="line">        &#123;</span><br><span class="line">            tempName = pi.Name;</span><br><span class="line">            if (dt.Columns.Contains(tempName))</span><br><span class="line">            &#123;</span><br><span class="line">                if (!pi.CanWrite) continue;</span><br><span class="line">                object value = dr[tempName];</span><br><span class="line">                if (value != DBNull.Value)</span><br><span class="line">                    pi.SetValue(obj, value, null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.Add((T)obj);</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static List&lt;T&gt; ConvertToList&lt;T&gt;(IDataReader reader)</span><br><span class="line">&#123;</span><br><span class="line">    List&lt;T&gt; list = new List&lt;T&gt;(); // 定义集合</span><br><span class="line">    Type type = typeof(T); // 获得此模型的类型</span><br><span class="line">    string tempName = &quot;&quot;;</span><br><span class="line">    PropertyInfo[] propertys = type.GetProperties();// 获得此模型的公共属性</span><br><span class="line">    while (reader.Read())</span><br><span class="line">    &#123;</span><br><span class="line">        //新建一个模型</span><br><span class="line">        object obj = type.Assembly.CreateInstance(type.FullName);</span><br><span class="line">        foreach (PropertyInfo pi in propertys)</span><br><span class="line">        &#123;</span><br><span class="line">            tempName = pi.Name;</span><br><span class="line">            if (ReaderExists(reader, tempName))</span><br><span class="line">            &#123;</span><br><span class="line">                if (!pi.CanWrite) continue;</span><br><span class="line">                object value = reader[tempName];</span><br><span class="line">                if (value != DBNull.Value)</span><br><span class="line">                    pi.SetValue(obj, value, null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.Add((T)obj);</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static T ConvertToModel&lt;T&gt;(IDataReader reader)</span><br><span class="line">&#123;</span><br><span class="line">    Type type = typeof(T);</span><br><span class="line">    PropertyInfo[] proList = type.GetProperties();</span><br><span class="line">    //新建一个模型</span><br><span class="line">    object obj = type.Assembly.CreateInstance(type.FullName);</span><br><span class="line">    string tempName = &quot;&quot;;</span><br><span class="line">    if (reader.Read())</span><br><span class="line">    &#123;</span><br><span class="line">        foreach (PropertyInfo pi in proList)</span><br><span class="line">        &#123;</span><br><span class="line">            tempName = pi.Name;</span><br><span class="line">            if (ReaderExists(reader, pi.Name))</span><br><span class="line">            &#123;</span><br><span class="line">                if (!pi.CanWrite) continue;</span><br><span class="line">                object value = reader[tempName];</span><br><span class="line">                if (value != DBNull.Value)</span><br><span class="line">                    pi.SetValue(obj, value, null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (T)obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static T ConvertToModel&lt;T&gt;(DataRow row)</span><br><span class="line">&#123;</span><br><span class="line">    Type type = typeof(T);</span><br><span class="line">    PropertyInfo[] proList = type.GetProperties();</span><br><span class="line">    //新建一个模型</span><br><span class="line">    object obj = type.Assembly.CreateInstance(type.FullName);</span><br><span class="line">    string tempName = &quot;&quot;;</span><br><span class="line">    foreach (PropertyInfo pi in proList)</span><br><span class="line">    &#123;</span><br><span class="line">        tempName = pi.Name;</span><br><span class="line">        if (!string.IsNullOrEmpty(row[tempName].ToString()))</span><br><span class="line">        &#123;</span><br><span class="line">            if (!pi.CanWrite) continue;</span><br><span class="line">            object value = row[tempName];</span><br><span class="line">            if (value != DBNull.Value)</span><br><span class="line">                pi.SetValue(obj, value, null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (T)obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 验证reader是否存在某列</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;reader&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;param name=&quot;columnName&quot;&gt;&lt;/param&gt;</span><br><span class="line">/// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">private static bool ReaderExists(IDataReader reader, string columnName)</span><br><span class="line">&#123;</span><br><span class="line">    int count = reader.FieldCount;</span><br><span class="line">    for (int i = 0; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (reader.GetName(i).Equals(columnName))</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Reflex</tag>
      </tags>
  </entry>
  <entry>
    <title>对于异步的理解</title>
    <url>/2018/04/16/%E5%AF%B9%E4%BA%8E%E5%BC%82%E6%AD%A5%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p><strong>对于异步的理解</strong></p>
<p>  之前对于同步方法和使用async、await的异步方法很迷惑。我觉得等待执行结果的异步和同步方法有什么区别吗？他们的执行顺序都是一样的啊？不是都需要等待执行结果吗？  </p>
<span id="more"></span>

<p>  今天翻了一下《C#高级编程》，才算搞清楚这里面的差异，原来使用了async、await的异步是不会阻塞线程的。  </p>
<p>  首先说说关于同步方法和异步方法的区别。比如说web网站加载一些网络资源，是使用同步方法请求，那么此时web网站的用户界面将会阻塞，直到该方法完成对资源的网络调用，并完成结果分析。完成这些调用所需的时间取决与网络速度，以及服务器当前的工作量。</p>
<p>  对于用户来说，界面卡掉、一段时间的等待都是不愉快的。所以使用异步调用。</p>
<p>  异步可以避免阻塞，在此期间可以做更多的事情。但是异步有一个缺陷，相对于同步来说，它对于程序的流程充满了不确定性，顺序可能会颠倒。所以在某些场景，比如说有多个异步方法被调用，他们是有依赖关系的，后面的异步方法需要使用到之前异步方法的结果，我们需要按顺序调用这些异步方法，这个时候就需要使用async、await关键字来等待执行的结果，但是它不会阻塞线程。</p>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Async</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式六大原则</title>
    <url>/2018/04/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>设计模式六大原则</p>
<span id="more"></span>

<h1 id="开闭原则："><a href="#开闭原则：" class="headerlink" title="开闭原则："></a>开闭原则：</h1><pre><code> 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。  

 软件实体包括：  
      1.项目软件中按照一定的逻辑规则划分的模块  
      2.抽象和类  
      3.方法  

 如何使用：  
      1.抽象约束  
           1）通过接口或抽象类的扩展  
           2）参数类型、引用对象尽量使用接口或抽象类，而不是实现类  
           3）抽象层尽量保持稳定，一但确定即不允许修改  
      2.元数据（metadata）控制模块行为（配置文件参数控制）  
      3.制定项目章程  
      4.封装变化  
           1）将相同的变化封装到一个接口或者抽象类中  
           2）将不同的变化封装到不同的接口或者抽象类中，不应该有两个或两个以上不同的变化出现在同一个接口或者抽象类中  
</code></pre>
<h1 id="单一原则"><a href="#单一原则" class="headerlink" title="单一原则:"></a>单一原则:</h1><pre><code> 一个类只负责一项职责  
</code></pre>
<p>优点：<br>    1. 代码可读性高。<br>    2. 易维护。修改一项职责<br>    3. 不用担心会影响到其它的职责。  </p>
<h1 id="里氏替换原则："><a href="#里氏替换原则：" class="headerlink" title="里氏替换原则："></a>里氏替换原则：</h1><pre><code> 派生类对象能够替换其基类被使用  
</code></pre>
<p>  优点：<br>     可以在不改变基类的情况下扩展派生类。只需继承，无需改变。</p>
<h1 id="依赖倒置原则："><a href="#依赖倒置原则：" class="headerlink" title="依赖倒置原则："></a>依赖倒置原则：</h1><pre><code> 程序要依赖于抽象接口，而不是依赖具体的实现  
1. 高层模块不应依赖于底层模块，两者都需要依赖抽象  
2. 抽象不依赖具体的细节，细节依赖于抽象  
</code></pre>
<h1 id="接口隔离原则："><a href="#接口隔离原则：" class="headerlink" title="接口隔离原则："></a>接口隔离原则：</h1><pre><code> 客户端不应依赖它不需要的接口，类之间的依赖关系应建立在最小的接口上（不出现臃肿的接口，但“ 小 ”具有限度，需遵从单一职责原则）  
</code></pre>
<h1 id="迪米特法则："><a href="#迪米特法则：" class="headerlink" title="迪米特法则："></a>迪米特法则：</h1><pre><code> 一个实体应尽可能少的跟其他实体发生相互作用。致力于降低各类之间的耦合。  
 缺点：会造成大量中介类，增加系统复杂性  
</code></pre>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Desing</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu部署netcore网站无法访问</title>
    <url>/2020/03/15/Ubuntu%E9%83%A8%E7%BD%B2netcore%E7%BD%91%E7%AB%99%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<p>记录一次发布.netcore网站到linux上的问题</p>
<span id="more"></span>

<p>前几天应工作需要，在阿里云上部署一个测试站点。本以为分分钟的事情，没想到打脸了。</p>
<p>当时直接新建一个webapi项目，publish后直接上传到阿里云，随后设置nginx转发网站端口5000。</p>
<p>接着打开网站测试访问，结果傻眼了，502…..。</p>
<p>于是乎，使用dotnet命令行启动，指定端口8080，更改nginx配置转而监听8080。测试，又打不开。</p>
<p>明明是按照众大神的文章一步一步来的，怎么会出错呢？搞不明白。随后老老实实阅读微软官方文档，</p>
<p>终于发现问题所在。原来是我没有设置Kestrel的监听端口。</p>
<p>论基础的重要性！！！要好好读书o(╥﹏╥)o，夯实基本功。</p>
<p>经历说完了，接下来说说如何配置网站端口。</p>
<p>设置的方式有三种：</p>
<p><strong>第一种：Program类的CreateHostBuilder方法指定Urls</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IHostBuilder <span class="title">CreateHostBuilder</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> =&gt;</span><br><span class="line">            Host.CreateDefaultBuilder(args)</span><br><span class="line">                .ConfigureWebHostDefaults(webBuilder =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    webBuilder.UseUrls(<span class="string">&quot;http://*:8080&quot;</span>);</span><br><span class="line">                    webBuilder.UseStartup&lt;Startup&gt;();</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure>

<p><strong>第二种：使用配置文件Hosting.json</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;urls&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://*:8080&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>项目需要添加引用</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Microsoft.Extensions.Configuration.FileExtensions&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line"><span class="string">&quot;Microsoft.Extensions.Configuration.Json&quot;</span>: <span class="string">&quot;1.0.0&quot;</span></span><br></pre></td></tr></table></figure>

<p>Program代码</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IHostBuilder <span class="title">CreateHostBuilder</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> =&gt;</span><br><span class="line">            Host.CreateDefaultBuilder(args)</span><br><span class="line">                .ConfigureWebHostDefaults(webBuilder =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    webBuilder.UseStartup&lt;Startup&gt;();</span><br><span class="line">                &#125;).ConfigureHostConfiguration(configHost =&gt; &#123; </span><br><span class="line">                    configHost.SetBasePath(Directory.GetCurrentDirectory());</span><br><span class="line">                    configHost.AddJsonFile(<span class="string">&quot;hosting.json&quot;</span>, optional: <span class="literal">true</span>, reloadOnChange : <span class="literal">true</span>);</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure>

<p><strong>第三种：使用命令行配置</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dotnet demo.dll --environment development --urls <span class="string">&quot;http://*:8081&quot;</span></span><br></pre></td></tr></table></figure>

<p>项目需要添加引用</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Microsoft.Extensions.Configuration.CommandLine&quot;</span>: <span class="string">&quot;3.1.2&quot;</span></span><br></pre></td></tr></table></figure>

<p>Program代码</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IHostBuilder <span class="title">CreateHostBuilder</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> =&gt;</span><br><span class="line">            Host.CreateDefaultBuilder(args)</span><br><span class="line">                .ConfigureWebHostDefaults(webBuilder =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    webBuilder.UseStartup&lt;Startup&gt;();</span><br><span class="line">                &#125;).ConfigureHostConfiguration(configHost =&gt; &#123; </span><br><span class="line">                    configHost.AddCommandLine(args);</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure>

<p>注：三种方式可同时配置，但是具有优先级：UseUrls &lt; 文件配置 &lt; 命令行配置</p>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>.Netcore</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis工具类</title>
    <url>/2018/04/12/Redis%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<p>redis工具类</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class RedisConnector</span><br><span class="line">&#123;</span><br><span class="line">    public class RedisParseResult&lt;T&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        public bool success;</span><br><span class="line">        public T value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static string ConnectionString &#123; get; set; &#125;</span><br><span class="line">    private static ConnectionMultiplexer RedisConnection &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public RedisConnector(string redisConnectionString)</span><br><span class="line">    &#123;</span><br><span class="line">        ConnectionString = redisConnectionString;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            RedisConnection = ConnectionMultiplexer.Connect(ConnectionString);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (RedisConnectionException e)</span><br><span class="line">        &#123;</span><br><span class="line">            AILogger.LogError(e.Message, $&quot;Redis server : &#123;redisConnectionString&#125;&quot;).Wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void Initialize(string redisConnectionString)</span><br><span class="line">    &#123;</span><br><span class="line">        ConnectionString = redisConnectionString;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            RedisConnection = ConnectionMultiplexer.Connect(ConnectionString);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (RedisConnectionException e)</span><br><span class="line">        &#123;</span><br><span class="line">            AILogger.LogError(e.Message, $&quot;Redis server : &#123;redisConnectionString&#125;&quot;).Wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static IDatabase RedisStore =&gt; (null != RedisConnection) ? RedisConnection.GetDatabase() : ConnectionMultiplexer.Connect(ConnectionString).GetDatabase();</span><br><span class="line"></span><br><span class="line">    public static ConnectionMultiplexer Redis =&gt; RedisConnection ?? ConnectionMultiplexer.Connect(ConnectionString);</span><br><span class="line"></span><br><span class="line">    public async static Task&lt;bool&gt; Store(string key, string value, int expiry = 120, bool replace = false) =&gt; await RedisStore.StringSetAsync(key, value, TimeSpan.FromSeconds(expiry), replace ? When.Always : When.NotExists);</span><br><span class="line"></span><br><span class="line">    public async static Task&lt;bool&gt; Store(string key, long value, int expiry = 120, bool replace = false) =&gt; await RedisStore.StringSetAsync(key, value.ToString(), TimeSpan.FromSeconds(expiry), replace ? When.Always : When.NotExists);</span><br><span class="line"></span><br><span class="line">    public async static Task&lt;bool&gt; Store&lt;T&gt;(string key, T value, int expiry = 120, bool replace = false) =&gt; await RedisStore.StringSetAsync(key, JsonConvert.SerializeObject(value), TimeSpan.FromSeconds(expiry), replace ? When.Always : When.NotExists);</span><br><span class="line"></span><br><span class="line">    public static string Get(string key) =&gt; RedisStore.StringGet(key);</span><br><span class="line"></span><br><span class="line">    public static RedisParseResult&lt;T&gt; Get&lt;T&gt;(string key)</span><br><span class="line">    &#123;</span><br><span class="line">        var storedValue = RedisStore.StringGet(key);</span><br><span class="line">        if (string.IsNullOrEmpty(storedValue))</span><br><span class="line">            return new RedisParseResult&lt;T&gt; &#123; success = false &#125;;</span><br><span class="line">        else</span><br><span class="line">            return new RedisParseResult&lt;T&gt; &#123; success = true, value = JsonConvert.DeserializeObject&lt;T&gt;(storedValue) &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLServer批量修改和插入</title>
    <url>/2023/07/12/SQLServer%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E5%92%8C%E6%8F%92%E5%85%A5/</url>
    <content><![CDATA[<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>今天在工作中遇到这么一个场景，我需要根据条件对表A做批量更新或插入。因为条件比较复杂，所以我使用了临时表B，先把需要更新或插入的数据查询出来放入临时表。然后更新表A的某字段，更新条件是A.id &#x3D; B.id，更新效果是若记录存在表A中，则更新表A的字段，若不在表A中，则插入一条记录到表A。</p>
<span id="more"></span>

<h1 id="初始方案"><a href="#初始方案" class="headerlink" title="初始方案"></a>初始方案</h1><p>首先想到的是写两条SQL：</p>
<ol>
<li>update使用A.id in (select id from B)，这时会更新所有存在的记录的字段，不存在则不更新</li>
<li>接下来再使用insert，条件是A.id not in (select id from B)，把A不存在未更新的数据插入到A</li>
</ol>
<p>两条SQL执行完，则完成了所有数据的更新和插入。</p>
<h1 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h1><p>后面有朋友提示可以使用SQL Merge语句做这件事情，由于对数据库并不熟悉，所以不知道还有这么一个语法。我查阅了相关资料，发现Merge确实很合适这个场景。参考<a href="https://www.yiibai.com/sqlserver/sql-server-merge.html">SQL Server Merge语句 - SQL Server教程 (yiibai.com)</a>重构了代码</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">into</span> #B </span><br><span class="line">	<span class="keyword">from</span> A  <span class="keyword">where</span> ... </span><br><span class="line"></span><br><span class="line"><span class="keyword">merge</span> [A] a <span class="keyword">using</span> #B b  </span><br><span class="line">    <span class="keyword">on</span> a.id <span class="operator">=</span> b.id  </span><br><span class="line">    <span class="keyword">when</span> matched  </span><br><span class="line">	    <span class="keyword">then</span> <span class="keyword">update</span> <span class="keyword">set</span> a.field <span class="operator">=</span> <span class="number">1</span> </span><br><span class="line">    <span class="keyword">when</span> <span class="keyword">not</span> matched <span class="keyword">by</span> target  </span><br><span class="line">	    <span class="keyword">then</span> <span class="keyword">insert</span> (field)  </span><br><span class="line">		<span class="keyword">values</span> (b.id);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>SQL Server</tag>
      </tags>
  </entry>
</search>
